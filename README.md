# README

We used dddappp, a low-code platform, to develop this game.
Although dddappp is not specifically designed for game development, it is perfectly suited as a "fully on-chain game engine".

Developing fully on-chain games with dddappp is incredibly easy.

All we need to do is do requirements analysis and domain modeling, then write the DDDML model files, 
then run the dddappp builder to generate most of the code, 
and then fill in a small amount of business logic in specific places, 
and we're done with the development of a fully on-chain game.


## Requirements analysis and domain modeling

[TBD]


## Programming

### Writing DDDML model files

The model files are located in the directory `. /dddml`.

### Generating code


```shell
docker run \
-v .:/myapp \
wubuku/dddappp:0.0.1 \
--dddmlDirectoryPath /myapp/dddml \
--boundedContextName Dddml.SuiInfiniteSea \
--suiMoveProjectDirectoryPath /myapp/sui-contracts \
--boundedContextSuiPackageName infinite_sea \
--boundedContextJavaPackageName org.dddml.suiinfinitesea \
--javaProjectsDirectoryPath /myapp/sui-java-service \
--javaProjectNamePrefix suiinfinitesea \
--pomGroupId dddml.suiinfinitesea \
--enableMultipleMoveProjects
```


### Implementing business logic

After generating the code, we need to fill in some business logic implementation.

As you can see, all the files starting with `// <autogenerated>` in the source code of our repository are generated by the dddappp tool,
and we should not modify them. They make up the majority of the code.

The other files that we need to fill in with business logic are also scaffolded by the dddappp tool, 
i.e., the signatures of the functions, and we only need to fill in the "body" part of them.

Specifically, we mainly fill in the file ending with `_logic.move` with the implementation of the methods of the entities defined in the model.

If you have defined "domain services" in the domain model, 
then you also need to fill in the files ending with `_service.move` with implementations of the "domain services".
In general, they should be a thin layer, 
which is a combination of invocations of the methods of the entities in the domain model and does not contain complex business logic.

It's worth noting that the off-chain service (sometimes called "indexer") is 100% auto-generated.
You don't even need to write a single line of code, 
you just need to configure the digests of transactions that publish the contracts, and you're ready to go.


## Test application


### Test off-chain service

#### Configuring off-chain service

Open the `application-test.yml` file located in the directory `sui-java-service/suiinfinitesea-service-rest/src/main/resources` and set the publishing transaction digests.

After setting, it should look like this:

```yaml
sui:
  contract:
    jsonrpc:
      url: "https://fullnode.testnet.sui.io/"
    package-publish-transactions:
      common: "{COMMON_PACKAGE_PUBLISH_TRANSACTION_DIGEST}"
      default: "{DEFAULT_PACKAGE_PUBLISH_TRANSACTION_DIGEST}"
```

This is the only place where off-chain service need to be configured, and it's that simple.


#### Creating a database for off-chain service

Use a MySQL client to connect to the local MySQL server and execute the following script to create an empty database (assuming the name is `test5`):

```sql
CREATE SCHEMA `test7` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;
```

Go to the `sui-java-service` directory and package the Java project:

```shell
mvn package
```

Then, run a command-line tool to initialize the database:

```shell
java -jar ./suiinfinitesea-service-cli/target/suiinfinitesea-service-cli-0.0.1-SNAPSHOT.jar ddl -d "./scripts" -c "jdbc:mysql://127.0.0.1:3306/test7?enabledTLSProtocols=TLSv1.2&characterEncoding=utf8&serverTimezone=GMT%2b0&useLegacyDatetimeCode=false" -u root -p 123456
```

#### Starting off-chain service

In the `sui-java-service` directory, execute the following command to start the off-chain service:

```shell
mvn -pl suiinfinitesea-service-rest -am spring-boot:run
```



