// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea_smithing::smithing_item_production {
    use infinite_sea_common::item_production::ItemProduction;
    use std::option;
    use sui::event;
    use sui::object::{Self, UID};
    use sui::table;
    use sui::transfer;
    use sui::tx_context::TxContext;
    friend infinite_sea_smithing::smithing_item_production_aggregate;

    const EIdAlreadyExists: u64 = 101;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;

    struct SmithingItemProductionTable has key {
        id: UID,
        table: table::Table<u32, object::ID>,
    }

    struct SmithingItemProductionTableCreated has copy, drop {
        id: object::ID,
    }

    fun init(ctx: &mut TxContext) {
        let id_generator_table = SmithingItemProductionTable {
            id: object::new(ctx),
            table: table::new(ctx),
        };
        let id_generator_table_id = object::uid_to_inner(&id_generator_table.id);
        transfer::share_object(id_generator_table);
        event::emit(SmithingItemProductionTableCreated {
            id: id_generator_table_id,
        });
    }

    struct SmithingItemProduction has key {
        id: UID,
        item_id: u32,
        version: u64,
        item_production: ItemProduction,
    }

    public fun id(smithing_item_production: &SmithingItemProduction): object::ID {
        object::uid_to_inner(&smithing_item_production.id)
    }

    public fun item_id(smithing_item_production: &SmithingItemProduction): u32 {
        smithing_item_production.item_id
    }

    public fun version(smithing_item_production: &SmithingItemProduction): u64 {
        smithing_item_production.version
    }

    public fun item_production(smithing_item_production: &SmithingItemProduction): ItemProduction {
        smithing_item_production.item_production
    }

    public(friend) fun set_item_production(smithing_item_production: &mut SmithingItemProduction, item_production: ItemProduction) {
        smithing_item_production.item_production = item_production;
    }

    fun new_smithing_item_production(
        item_id: u32,
        item_production: ItemProduction,
        ctx: &mut TxContext,
    ): SmithingItemProduction {
        SmithingItemProduction {
            id: object::new(ctx),
            item_id,
            version: 0,
            item_production,
        }
    }


    public(friend) fun create_smithing_item_production(
        item_id: u32,
        item_production: ItemProduction,
        smithing_item_production_table: &mut SmithingItemProductionTable,
        ctx: &mut TxContext,
    ): SmithingItemProduction {
        let smithing_item_production = new_smithing_item_production(
            item_id,
            item_production,
            ctx,
        );
        asset_item_id_not_exists_then_add(item_id, smithing_item_production_table, object::uid_to_inner(&smithing_item_production.id));
        smithing_item_production
    }

    public(friend) fun asset_item_id_not_exists(
        item_id: u32,
        smithing_item_production_table: &SmithingItemProductionTable,
    ) {
        assert!(!table::contains(&smithing_item_production_table.table, item_id), EIdAlreadyExists);
    }

    fun asset_item_id_not_exists_then_add(
        item_id: u32,
        smithing_item_production_table: &mut SmithingItemProductionTable,
        id: object::ID,
    ) {
        asset_item_id_not_exists(item_id, smithing_item_production_table);
        table::add(&mut smithing_item_production_table.table, item_id, id);
    }

    public(friend) fun transfer_object(smithing_item_production: SmithingItemProduction, recipient: address) {
        assert!(smithing_item_production.version == 0, EInappropriateVersion);
        transfer::transfer(smithing_item_production, recipient);
    }

    public(friend) fun update_version_and_transfer_object(smithing_item_production: SmithingItemProduction, recipient: address) {
        update_object_version(&mut smithing_item_production);
        transfer::transfer(smithing_item_production, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object(smithing_item_production: SmithingItemProduction) {
        assert!(smithing_item_production.version == 0, EInappropriateVersion);
        transfer::share_object(smithing_item_production);
    }

    public(friend) fun freeze_object(smithing_item_production: SmithingItemProduction) {
        assert!(smithing_item_production.version == 0, EInappropriateVersion);
        transfer::freeze_object(smithing_item_production);
    }

    public(friend) fun update_version_and_freeze_object(smithing_item_production: SmithingItemProduction) {
        update_object_version(&mut smithing_item_production);
        transfer::freeze_object(smithing_item_production);
    }

    fun update_object_version(smithing_item_production: &mut SmithingItemProduction) {
        smithing_item_production.version = smithing_item_production.version + 1;
        //assert!(smithing_item_production.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_smithing_item_production(smithing_item_production: SmithingItemProduction) {
        let SmithingItemProduction {
            id,
            item_id: _item_id,
            version: _version,
            item_production: _item_production,
        } = smithing_item_production;
        object::delete(id);
    }

    #[test_only]
    /// Wrapper of module initializer for testing
    public fun test_init(ctx: &mut TxContext) {
        init(ctx)
    }

}
