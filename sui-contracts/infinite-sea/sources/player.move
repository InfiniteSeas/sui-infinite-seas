// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea::player {
    use infinite_sea::player_item::{Self, PlayerItem};
    use infinite_sea_common::production_material::ProductionMaterial;
    use std::option;
    use sui::event;
    use sui::object::{Self, UID};
    use sui::table;
    use sui::transfer;
    use sui::tx_context::TxContext;

    struct PLAYER has drop {}

    friend infinite_sea::player_create_logic;
    friend infinite_sea::player_airdrop_logic;
    friend infinite_sea::player_deduct_items_logic;
    friend infinite_sea::player_increase_experience_and_items_logic;
    friend infinite_sea::player_aggregate;

    const EIdAlreadyExists: u64 = 101;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;
    const EIdNotFound: u64 = 111;

    struct PlayerTable has key {
        id: UID,
        table: table::Table<address, object::ID>,
    }

    struct PlayerTableCreated has copy, drop {
        id: object::ID,
    }

    fun init(otw: PLAYER, ctx: &mut TxContext) {
        sui::package::claim_and_keep(otw, ctx);
        let id_generator_table = PlayerTable {
            id: object::new(ctx),
            table: table::new(ctx),
        };
        let id_generator_table_id = object::uid_to_inner(&id_generator_table.id);
        transfer::share_object(id_generator_table);
        event::emit(PlayerTableCreated {
            id: id_generator_table_id,
        });
    }

    struct Player has key {
        id: UID,
        player_id: address,
        version: u64,
        level: u16,
        experience: u32,
        items: table::Table<u32, PlayerItem>,
    }

    public fun id(player: &Player): object::ID {
        object::uid_to_inner(&player.id)
    }

    public fun player_id(player: &Player): address {
        player.player_id
    }

    public fun version(player: &Player): u64 {
        player.version
    }

    public fun level(player: &Player): u16 {
        player.level
    }

    public(friend) fun set_level(player: &mut Player, level: u16) {
        player.level = level;
    }

    public fun experience(player: &Player): u32 {
        player.experience
    }

    public(friend) fun set_experience(player: &mut Player, experience: u32) {
        player.experience = experience;
    }

    public(friend) fun add_item(player: &mut Player, item: PlayerItem) {
        let key = player_item::item_id(&item);
        assert!(!table::contains(&player.items, key), EIdAlreadyExists);
        table::add(&mut player.items, key, item);
    }

    public(friend) fun remove_item(player: &mut Player, item_id: u32) {
        assert!(table::contains(&player.items, item_id), EIdNotFound);
        let item = table::remove(&mut player.items, item_id);
        player_item::drop_player_item(item);
    }

    public(friend) fun borrow_mut_item(player: &mut Player, item_id: u32): &mut PlayerItem {
        table::borrow_mut(&mut player.items, item_id)
    }

    public fun borrow_item(player: &Player, item_id: u32): &PlayerItem {
        table::borrow(&player.items, item_id)
    }

    public fun items_contains(player: &Player, item_id: u32): bool {
        table::contains(&player.items, item_id)
    }

    public fun items_length(player: &Player): u64 {
        table::length(&player.items)
    }

    fun new_player(
        player_id: address,
        level: u16,
        experience: u32,
        ctx: &mut TxContext,
    ): Player {
        Player {
            id: object::new(ctx),
            player_id,
            version: 0,
            level,
            experience,
            items: table::new<u32, PlayerItem>(ctx),
        }
    }

    struct PlayerCreated has copy, drop {
        id: option::Option<object::ID>,
        player_id: address,
        level: u16,
        experience: u32,
    }

    public fun player_created_id(player_created: &PlayerCreated): option::Option<object::ID> {
        player_created.id
    }

    public(friend) fun set_player_created_id(player_created: &mut PlayerCreated, id: object::ID) {
        player_created.id = option::some(id);
    }

    public fun player_created_player_id(player_created: &PlayerCreated): address {
        player_created.player_id
    }

    public fun player_created_level(player_created: &PlayerCreated): u16 {
        player_created.level
    }

    public fun player_created_experience(player_created: &PlayerCreated): u32 {
        player_created.experience
    }

    public(friend) fun new_player_created(
        player_id: address,
        level: u16,
        experience: u32,
    ): PlayerCreated {
        PlayerCreated {
            id: option::none(),
            player_id,
            level,
            experience,
        }
    }

    struct PlayerAirdropped has copy, drop {
        id: object::ID,
        player_id: address,
        version: u64,
        item_id: u32,
        quantity: u32,
    }

    public fun player_airdropped_id(player_airdropped: &PlayerAirdropped): object::ID {
        player_airdropped.id
    }

    public fun player_airdropped_player_id(player_airdropped: &PlayerAirdropped): address {
        player_airdropped.player_id
    }

    public fun player_airdropped_item_id(player_airdropped: &PlayerAirdropped): u32 {
        player_airdropped.item_id
    }

    public fun player_airdropped_quantity(player_airdropped: &PlayerAirdropped): u32 {
        player_airdropped.quantity
    }

    public(friend) fun new_player_airdropped(
        player: &Player,
        item_id: u32,
        quantity: u32,
    ): PlayerAirdropped {
        PlayerAirdropped {
            id: id(player),
            player_id: player_id(player),
            version: version(player),
            item_id,
            quantity,
        }
    }

    struct PlayerItemsDeducted has copy, drop {
        id: object::ID,
        player_id: address,
        version: u64,
        items: vector<ProductionMaterial>,
    }

    public fun player_items_deducted_id(player_items_deducted: &PlayerItemsDeducted): object::ID {
        player_items_deducted.id
    }

    public fun player_items_deducted_player_id(player_items_deducted: &PlayerItemsDeducted): address {
        player_items_deducted.player_id
    }

    public fun player_items_deducted_items(player_items_deducted: &PlayerItemsDeducted): vector<ProductionMaterial> {
        player_items_deducted.items
    }

    public(friend) fun new_player_items_deducted(
        player: &Player,
        items: vector<ProductionMaterial>,
    ): PlayerItemsDeducted {
        PlayerItemsDeducted {
            id: id(player),
            player_id: player_id(player),
            version: version(player),
            items,
        }
    }

    struct PlayerExperienceAndItemsIncreased has copy, drop {
        id: object::ID,
        player_id: address,
        version: u64,
        experience: u32,
        items: vector<ProductionMaterial>,
        new_level: u16,
    }

    public fun player_experience_and_items_increased_id(player_experience_and_items_increased: &PlayerExperienceAndItemsIncreased): object::ID {
        player_experience_and_items_increased.id
    }

    public fun player_experience_and_items_increased_player_id(player_experience_and_items_increased: &PlayerExperienceAndItemsIncreased): address {
        player_experience_and_items_increased.player_id
    }

    public fun player_experience_and_items_increased_experience(player_experience_and_items_increased: &PlayerExperienceAndItemsIncreased): u32 {
        player_experience_and_items_increased.experience
    }

    public fun player_experience_and_items_increased_items(player_experience_and_items_increased: &PlayerExperienceAndItemsIncreased): vector<ProductionMaterial> {
        player_experience_and_items_increased.items
    }

    public fun player_experience_and_items_increased_new_level(player_experience_and_items_increased: &PlayerExperienceAndItemsIncreased): u16 {
        player_experience_and_items_increased.new_level
    }

    public(friend) fun new_player_experience_and_items_increased(
        player: &Player,
        experience: u32,
        items: vector<ProductionMaterial>,
        new_level: u16,
    ): PlayerExperienceAndItemsIncreased {
        PlayerExperienceAndItemsIncreased {
            id: id(player),
            player_id: player_id(player),
            version: version(player),
            experience,
            items,
            new_level,
        }
    }


    public(friend) fun create_player(
        player_id: address,
        level: u16,
        experience: u32,
        player_table: &mut PlayerTable,
        ctx: &mut TxContext,
    ): Player {
        let player = new_player(
            player_id,
            level,
            experience,
            ctx,
        );
        asset_player_id_not_exists_then_add(player_id, player_table, object::uid_to_inner(&player.id));
        player
    }

    public(friend) fun asset_player_id_not_exists(
        player_id: address,
        player_table: &PlayerTable,
    ) {
        assert!(!table::contains(&player_table.table, player_id), EIdAlreadyExists);
    }

    fun asset_player_id_not_exists_then_add(
        player_id: address,
        player_table: &mut PlayerTable,
        id: object::ID,
    ) {
        asset_player_id_not_exists(player_id, player_table);
        table::add(&mut player_table.table, player_id, id);
    }

    public(friend) fun transfer_object(player: Player, recipient: address) {
        assert!(player.version == 0, EInappropriateVersion);
        transfer::transfer(player, recipient);
    }

    public(friend) fun update_version_and_transfer_object(player: Player, recipient: address) {
        update_object_version(&mut player);
        transfer::transfer(player, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object(player: Player) {
        assert!(player.version == 0, EInappropriateVersion);
        transfer::share_object(player);
    }

    #[lint_allow(freeze_wrapped)]
    public(friend) fun freeze_object(player: Player) {
        assert!(player.version == 0, EInappropriateVersion);
        transfer::freeze_object(player);
    }

    #[lint_allow(freeze_wrapped)]
    public(friend) fun update_version_and_freeze_object(player: Player) {
        update_object_version(&mut player);
        transfer::freeze_object(player);
    }

    public(friend) fun update_object_version(player: &mut Player) {
        player.version = player.version + 1;
        //assert!(player.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_player(player: Player) {
        let Player {
            id,
            player_id: _player_id,
            version: _version,
            level: _level,
            experience: _experience,
            items,
        } = player;
        object::delete(id);
        table::destroy_empty(items);
    }

    public(friend) fun emit_player_created(player_created: PlayerCreated) {
        assert!(std::option::is_some(&player_created.id), EEmptyObjectID);
        event::emit(player_created);
    }

    public(friend) fun emit_player_airdropped(player_airdropped: PlayerAirdropped) {
        event::emit(player_airdropped);
    }

    public(friend) fun emit_player_items_deducted(player_items_deducted: PlayerItemsDeducted) {
        event::emit(player_items_deducted);
    }

    public(friend) fun emit_player_experience_and_items_increased(player_experience_and_items_increased: PlayerExperienceAndItemsIncreased) {
        event::emit(player_experience_and_items_increased);
    }

}
