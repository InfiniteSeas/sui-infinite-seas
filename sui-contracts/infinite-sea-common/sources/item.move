// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea_common::item {
    use std::option;
    use sui::event;
    use sui::object::{Self, UID};
    use sui::table;
    use sui::transfer;
    use sui::tx_context::TxContext;

    struct ITEM has drop {}

    friend infinite_sea_common::item_create_logic;
    friend infinite_sea_common::item_update_logic;
    friend infinite_sea_common::item_aggregate;

    const EIdAlreadyExists: u64 = 101;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;

    struct ItemTable has key {
        id: UID,
        table: table::Table<u32, object::ID>,
    }

    struct ItemTableCreated has copy, drop {
        id: object::ID,
    }

    fun init(otw: ITEM, ctx: &mut TxContext) {
        sui::package::claim_and_keep(otw, ctx);
        let id_generator_table = ItemTable {
            id: object::new(ctx),
            table: table::new(ctx),
        };
        let id_generator_table_id = object::uid_to_inner(&id_generator_table.id);
        transfer::share_object(id_generator_table);
        event::emit(ItemTableCreated {
            id: id_generator_table_id,
        });
    }

    struct Item has key {
        id: UID,
        item_id: u32,
        version: u64,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
    }

    public fun id(item: &Item): object::ID {
        object::uid_to_inner(&item.id)
    }

    public fun item_id(item: &Item): u32 {
        item.item_id
    }

    public fun version(item: &Item): u64 {
        item.version
    }

    public fun name(item: &Item): std::ascii::String {
        item.name
    }

    public(friend) fun set_name(item: &mut Item, name: std::ascii::String) {
        item.name = name;
    }

    public fun required_for_completion(item: &Item): bool {
        item.required_for_completion
    }

    public(friend) fun set_required_for_completion(item: &mut Item, required_for_completion: bool) {
        item.required_for_completion = required_for_completion;
    }

    public fun sells_for(item: &Item): u32 {
        item.sells_for
    }

    public(friend) fun set_sells_for(item: &mut Item, sells_for: u32) {
        item.sells_for = sells_for;
    }

    fun new_item(
        item_id: u32,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
        ctx: &mut TxContext,
    ): Item {
        Item {
            id: object::new(ctx),
            item_id,
            version: 0,
            name,
            required_for_completion,
            sells_for,
        }
    }

    struct ItemCreated has copy, drop {
        id: option::Option<object::ID>,
        item_id: u32,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
    }

    public fun item_created_id(item_created: &ItemCreated): option::Option<object::ID> {
        item_created.id
    }

    public(friend) fun set_item_created_id(item_created: &mut ItemCreated, id: object::ID) {
        item_created.id = option::some(id);
    }

    public fun item_created_item_id(item_created: &ItemCreated): u32 {
        item_created.item_id
    }

    public fun item_created_name(item_created: &ItemCreated): std::ascii::String {
        item_created.name
    }

    public fun item_created_required_for_completion(item_created: &ItemCreated): bool {
        item_created.required_for_completion
    }

    public fun item_created_sells_for(item_created: &ItemCreated): u32 {
        item_created.sells_for
    }

    public(friend) fun new_item_created(
        item_id: u32,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
    ): ItemCreated {
        ItemCreated {
            id: option::none(),
            item_id,
            name,
            required_for_completion,
            sells_for,
        }
    }

    struct ItemUpdated has copy, drop {
        id: object::ID,
        item_id: u32,
        version: u64,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
    }

    public fun item_updated_id(item_updated: &ItemUpdated): object::ID {
        item_updated.id
    }

    public fun item_updated_item_id(item_updated: &ItemUpdated): u32 {
        item_updated.item_id
    }

    public fun item_updated_name(item_updated: &ItemUpdated): std::ascii::String {
        item_updated.name
    }

    public fun item_updated_required_for_completion(item_updated: &ItemUpdated): bool {
        item_updated.required_for_completion
    }

    public fun item_updated_sells_for(item_updated: &ItemUpdated): u32 {
        item_updated.sells_for
    }

    public(friend) fun new_item_updated(
        item: &Item,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
    ): ItemUpdated {
        ItemUpdated {
            id: id(item),
            item_id: item_id(item),
            version: version(item),
            name,
            required_for_completion,
            sells_for,
        }
    }


    public(friend) fun create_item(
        item_id: u32,
        name: std::ascii::String,
        required_for_completion: bool,
        sells_for: u32,
        item_table: &mut ItemTable,
        ctx: &mut TxContext,
    ): Item {
        let item = new_item(
            item_id,
            name,
            required_for_completion,
            sells_for,
            ctx,
        );
        asset_item_id_not_exists_then_add(item_id, item_table, object::uid_to_inner(&item.id));
        item
    }

    public(friend) fun asset_item_id_not_exists(
        item_id: u32,
        item_table: &ItemTable,
    ) {
        assert!(!table::contains(&item_table.table, item_id), EIdAlreadyExists);
    }

    fun asset_item_id_not_exists_then_add(
        item_id: u32,
        item_table: &mut ItemTable,
        id: object::ID,
    ) {
        asset_item_id_not_exists(item_id, item_table);
        table::add(&mut item_table.table, item_id, id);
    }

    public(friend) fun transfer_object(item: Item, recipient: address) {
        assert!(item.version == 0, EInappropriateVersion);
        transfer::transfer(item, recipient);
    }

    public(friend) fun update_version_and_transfer_object(item: Item, recipient: address) {
        update_object_version(&mut item);
        transfer::transfer(item, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object(item: Item) {
        assert!(item.version == 0, EInappropriateVersion);
        transfer::share_object(item);
    }

    public(friend) fun freeze_object(item: Item) {
        assert!(item.version == 0, EInappropriateVersion);
        transfer::freeze_object(item);
    }

    public(friend) fun update_version_and_freeze_object(item: Item) {
        update_object_version(&mut item);
        transfer::freeze_object(item);
    }

    public(friend) fun update_object_version(item: &mut Item) {
        item.version = item.version + 1;
        //assert!(item.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_item(item: Item) {
        let Item {
            id,
            item_id: _item_id,
            version: _version,
            name: _name,
            required_for_completion: _required_for_completion,
            sells_for: _sells_for,
        } = item;
        object::delete(id);
    }

    public(friend) fun emit_item_created(item_created: ItemCreated) {
        assert!(std::option::is_some(&item_created.id), EEmptyObjectID);
        event::emit(item_created);
    }

    public(friend) fun emit_item_updated(item_updated: ItemUpdated) {
        event::emit(item_updated);
    }

    #[test_only]
    /// Wrapper of module initializer for testing
    public fun test_init(ctx: &mut TxContext) {
        init(ctx)
    }

}
