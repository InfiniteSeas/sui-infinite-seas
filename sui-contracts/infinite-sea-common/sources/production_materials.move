// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea_common::production_materials {
    use infinite_sea_common::production_material::ProductionMaterial;
    use std::option::Option;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;

    struct ProductionMaterials has store, drop, copy {
        items: vector<ProductionMaterial>,
    }

    public fun new(
        material_item_id_1: u32,
        material_quantity_1: u32,
        material_item_id_2: Option<u32>,
        material_quantity_2: Option<u32>,
        material_item_id_3: Option<u32>,
        material_quantity_3: Option<u32>,
        material_item_id_4: Option<u32>,
        material_quantity_4: Option<u32>,
        material_item_id_5: Option<u32>,
        material_quantity_5: Option<u32>,
    ): ProductionMaterials {
        let items = std::vector::empty();
        std::vector::push_back(
            &mut items,
            infinite_sea_common::production_material::new(material_item_id_1, material_quantity_1)
        );
        if (std::option::is_some(&material_item_id_2)) {
            std::vector::push_back(
                &mut items,
                infinite_sea_common::production_material::new(
                    std::option::extract(&mut material_item_id_2),
                    std::option::extract(&mut material_quantity_2)
                )
            );
        };
        if (std::option::is_some(&material_item_id_3)) {
            std::vector::push_back(
                &mut items,
                infinite_sea_common::production_material::new(
                    std::option::extract(&mut material_item_id_3),
                    std::option::extract(&mut material_quantity_3)
                )
            );
        };
        if (std::option::is_some(&material_item_id_4)) {
            std::vector::push_back(
                &mut items,
                infinite_sea_common::production_material::new(
                    std::option::extract(&mut material_item_id_4),
                    std::option::extract(&mut material_quantity_4)
                )
            );
        };
        if (std::option::is_some(&material_item_id_5)) {
            std::vector::push_back(
                &mut items,
                infinite_sea_common::production_material::new(
                    std::option::extract(&mut material_item_id_5),
                    std::option::extract(&mut material_quantity_5)
                )
            );
        };
        let production_materials = ProductionMaterials {
            items,
        };
        validate(&production_materials);
        production_materials
    }

    fun validate(production_materials: &ProductionMaterials) {
        let _ = production_materials;
    }

    public fun items(production_materials: &ProductionMaterials): vector<ProductionMaterial> {
        production_materials.items
    }

    public fun borrow_items(production_materials: &ProductionMaterials): &vector<ProductionMaterial> {
        &production_materials.items
    }

}
