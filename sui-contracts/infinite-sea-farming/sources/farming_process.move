// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea_farming::farming_process {
    use std::option;
    use sui::event;
    use sui::object::{Self, UID};
    use sui::table;
    use sui::transfer;
    use sui::tx_context::TxContext;

    struct FARMING_PROCESS has drop {}

    friend infinite_sea_farming::farming_process_create_logic;
    friend infinite_sea_farming::farming_process_start_logic;
    friend infinite_sea_farming::farming_process_aggregate;

    const EIdAlreadyExists: u64 = 101;
    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;

    struct FarmingProcessTable has key {
        id: UID,
        table: table::Table<address, object::ID>,
    }

    struct FarmingProcessTableCreated has copy, drop {
        id: object::ID,
    }

    fun init(otw: FARMING_PROCESS, ctx: &mut TxContext) {
        sui::package::claim_and_keep(otw, ctx);
        let id_generator_table = FarmingProcessTable {
            id: object::new(ctx),
            table: table::new(ctx),
        };
        let id_generator_table_id = object::uid_to_inner(&id_generator_table.id);
        transfer::share_object(id_generator_table);
        event::emit(FarmingProcessTableCreated {
            id: id_generator_table_id,
        });
    }

    struct FarmingProcess has key {
        id: UID,
        player_id: address,
        version: u64,
        item_id: u32,
        start_time: u64,
        end_time: u64,
    }

    public fun id(farming_process: &FarmingProcess): object::ID {
        object::uid_to_inner(&farming_process.id)
    }

    public fun player_id(farming_process: &FarmingProcess): address {
        farming_process.player_id
    }

    public fun version(farming_process: &FarmingProcess): u64 {
        farming_process.version
    }

    public fun item_id(farming_process: &FarmingProcess): u32 {
        farming_process.item_id
    }

    public(friend) fun set_item_id(farming_process: &mut FarmingProcess, item_id: u32) {
        farming_process.item_id = item_id;
    }

    public fun start_time(farming_process: &FarmingProcess): u64 {
        farming_process.start_time
    }

    public(friend) fun set_start_time(farming_process: &mut FarmingProcess, start_time: u64) {
        farming_process.start_time = start_time;
    }

    public fun end_time(farming_process: &FarmingProcess): u64 {
        farming_process.end_time
    }

    public(friend) fun set_end_time(farming_process: &mut FarmingProcess, end_time: u64) {
        farming_process.end_time = end_time;
    }

    fun new_farming_process(
        player_id: address,
        ctx: &mut TxContext,
    ): FarmingProcess {
        FarmingProcess {
            id: object::new(ctx),
            player_id,
            version: 0,
            item_id: infinite_sea_common::item_id::unused_item(),
            start_time: 0,
            end_time: 0,
        }
    }

    struct FarmingProcessCreated has copy, drop {
        id: option::Option<object::ID>,
        player_id: address,
    }

    public fun farming_process_created_id(farming_process_created: &FarmingProcessCreated): option::Option<object::ID> {
        farming_process_created.id
    }

    public(friend) fun set_farming_process_created_id(farming_process_created: &mut FarmingProcessCreated, id: object::ID) {
        farming_process_created.id = option::some(id);
    }

    public fun farming_process_created_player_id(farming_process_created: &FarmingProcessCreated): address {
        farming_process_created.player_id
    }

    public(friend) fun new_farming_process_created(
        player_id: address,
    ): FarmingProcessCreated {
        FarmingProcessCreated {
            id: option::none(),
            player_id,
        }
    }

    struct FarmingProcessStarted has copy, drop {
        id: object::ID,
        player_id: address,
        version: u64,
        item_id: u32,
        energy_cost: u64,
    }

    public fun farming_process_started_id(farming_process_started: &FarmingProcessStarted): object::ID {
        farming_process_started.id
    }

    public fun farming_process_started_player_id(farming_process_started: &FarmingProcessStarted): address {
        farming_process_started.player_id
    }

    public fun farming_process_started_item_id(farming_process_started: &FarmingProcessStarted): u32 {
        farming_process_started.item_id
    }

    public fun farming_process_started_energy_cost(farming_process_started: &FarmingProcessStarted): u64 {
        farming_process_started.energy_cost
    }

    public(friend) fun new_farming_process_started(
        farming_process: &FarmingProcess,
        item_id: u32,
        energy_cost: u64,
    ): FarmingProcessStarted {
        FarmingProcessStarted {
            id: id(farming_process),
            player_id: player_id(farming_process),
            version: version(farming_process),
            item_id,
            energy_cost,
        }
    }


    public(friend) fun create_farming_process(
        player_id: address,
        farming_process_table: &mut FarmingProcessTable,
        ctx: &mut TxContext,
    ): FarmingProcess {
        let farming_process = new_farming_process(
            player_id,
            ctx,
        );
        asset_player_id_not_exists_then_add(player_id, farming_process_table, object::uid_to_inner(&farming_process.id));
        farming_process
    }

    public(friend) fun asset_player_id_not_exists(
        player_id: address,
        farming_process_table: &FarmingProcessTable,
    ) {
        assert!(!table::contains(&farming_process_table.table, player_id), EIdAlreadyExists);
    }

    fun asset_player_id_not_exists_then_add(
        player_id: address,
        farming_process_table: &mut FarmingProcessTable,
        id: object::ID,
    ) {
        asset_player_id_not_exists(player_id, farming_process_table);
        table::add(&mut farming_process_table.table, player_id, id);
    }

    public(friend) fun transfer_object(farming_process: FarmingProcess, recipient: address) {
        assert!(farming_process.version == 0, EInappropriateVersion);
        transfer::transfer(farming_process, recipient);
    }

    public(friend) fun update_version_and_transfer_object(farming_process: FarmingProcess, recipient: address) {
        update_object_version(&mut farming_process);
        transfer::transfer(farming_process, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object(farming_process: FarmingProcess) {
        assert!(farming_process.version == 0, EInappropriateVersion);
        transfer::share_object(farming_process);
    }

    public(friend) fun freeze_object(farming_process: FarmingProcess) {
        assert!(farming_process.version == 0, EInappropriateVersion);
        transfer::freeze_object(farming_process);
    }

    public(friend) fun update_version_and_freeze_object(farming_process: FarmingProcess) {
        update_object_version(&mut farming_process);
        transfer::freeze_object(farming_process);
    }

    public(friend) fun update_object_version(farming_process: &mut FarmingProcess) {
        farming_process.version = farming_process.version + 1;
        //assert!(farming_process.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_farming_process(farming_process: FarmingProcess) {
        let FarmingProcess {
            id,
            player_id: _player_id,
            version: _version,
            item_id: _item_id,
            start_time: _start_time,
            end_time: _end_time,
        } = farming_process;
        object::delete(id);
    }

    public(friend) fun emit_farming_process_created(farming_process_created: FarmingProcessCreated) {
        assert!(std::option::is_some(&farming_process_created.id), EEmptyObjectID);
        event::emit(farming_process_created);
    }

    public(friend) fun emit_farming_process_started(farming_process_started: FarmingProcessStarted) {
        event::emit(farming_process_started);
    }

}
