# README

我们使用 dddappp 这个低代码平台来开发这个游戏。虽然 dddappp 并不是专门为游戏开发设计的，但是它完全可以作为一个“全链游戏引擎”来使用。

使用 dddappp 开发全链游戏令人难以置信地简单。

我们只要先做好需求分析和领域建模，然后编写 DDDML 模型文件，再运行 dddappp 创建工具，生成大部分代码，然后在某些特定地方填充少量的业务逻辑的实现，就可以完成一个全链游戏的开发。


## 需求分析与领域建模

### Items

### Skills

Item（物品）有两种“生产/创造”方式：

* Item Production。需要“原材料”，生产时需要消耗一定数量的原材料（其他 Items）。我们可以限制一下，生产配方最多使用 5 种原材料（应该已经足够）。
* Item Creation。不需要原材料。

同一种东西（Item），是可能可以通过不同的技能（Skill）获得的。比如你可以通过 “Farming” 技能种植、收获一种农产品，也可以“偷窃”技能获得它。

Skill（技能）要么是生产（Production）型的技能，要么是创造（Creation）型的技能，不会两者都是。比如：

* Farming（农业）是生产型的技能。需要消耗“种子”（原材料 items）。种子可以从市场购买、可以“偷窃”（偷窃是创造型的技能）或者使用其他技能获得。
* Mining（挖矿）是创造型的技能。我们需要给这些创造型的技能的使用做一些“资源限制”。这个限制是针对技能类型使用的次数（或者点数）的配额限制。
    而不是像生产型技能那样，通过“生产配方”需要具体的原材料的 item 和消耗数量来达成限制。

### Skill Processes

首先，“每种技能”最多只能有一个进程（Process）在执行。
并且，有些类型的技能的进程（Process）是互斥的。也就是说，同一个时间点，这些类型的技能只能存在一个正在执行的进程。
不过，这些互斥的技能中的一个进程，可以和其他类型（非互斥）的技能进程并行执行。


[TBD]


## 编码

### 编写 DDDML 模型文件

模型文件位于目录 `./dddml` 下。

### 生成代码

```shell
docker run \
-v .:/myapp \
wubuku/dddappp:0.0.1 \
--dddmlDirectoryPath /myapp/dddml \
--boundedContextName Dddml.SuiInfiniteSea \
--suiMoveProjectDirectoryPath /myapp/sui-contracts \
--boundedContextSuiPackageName infinite_sea \
--boundedContextJavaPackageName org.dddml.suiinfinitesea \
--javaProjectsDirectoryPath /myapp/sui-java-service \
--javaProjectNamePrefix suiinfinitesea \
--pomGroupId dddml.suiinfinitesea \
--enableMultipleMoveProjects
```

### 实现业务逻辑

在生成代码后，我们需要填充一些业务逻辑的实现。

你可以看到，在我们这个代码库的源代码中，所有以 `// <autogenerated>` 开头的文件，都是由 dddappp 工具生成的，我们不应该修改它们。这些代码占了整个代码库的绝大部分。

其他需要我们填充业务逻辑的文件，dddappp 工具也帮我们生成了脚手架代码，也就是函数的签名部分，我们只需要填充其中的“函数体”（body）部分。

具体来说，我们主要是在以 `_logic.move` 结尾的文件中填充模型中定义的“实体的方法”的实现。

如果你在领域模型中定义了“领域服务”，那么，还需要在以 `_service.move` 结尾的文件中填充“领域服务”的实现。
一般来说，它们应该是很薄的一层“包装”代码，只是对领域模型中的实体的方法的组合调用，不会包含复杂的业务逻辑。

值得一提的是，链下服务（off-chain service，有时候会被称为 indexer）是 100% 自动生成的。
你甚至一行代码都不需要写，只需要配置一下发布合约的交易摘要，就可以直接使用了。


## 测试应用

### 发布 coin 合约

能量（`ENERGY`）币的合约项目在 `./sui-contracts/infinite-sea-coin` 目录。

进入目录，发布合约：

```shell
sui client publish --gas-budget 200000000 --skip-dependency-verification --skip-fetch-latest-git-deps
```

记录输出中的合约 Package ID。下面的命令使用占位符 `{COIN_PACKAGE_ID}` 来表示它。

记录输出中的 TreasuryCap 的 Object ID：

```text
│  ┌──
│  │ ObjectID: {ENERGY_COIN_TREASURY_CAP_OBJECT_ID}
│  │ ObjectType: 0x2::coin::TreasuryCap<{COIN_PACKAGE_ID}::energy::ENERGY>
```

合约的发布者可以给自己 mint 一些代币：

```shell
sui client call --package {COIN_PACKAGE_ID} --module energy --function mint \
--args {ENERGY_COIN_TREASURY_CAP_OBJECT_ID} '100000000' \
--gas-budget 19000000
```

记录 mint 获得的能量币的 Object ID。下面的命令使用占位符 `{ENERGY_COIN_OBJECT_ID_1}` 来表示它。


### 发布 common 合约包

发布 `./sui-contracts/infinite-sea-common` 目录下的合约项目包。

记录下输出中的交易摘要，下面的命令我们使用占位符 `{COMMON_PACKAGE_PUBLISH_TRANSACTION_DIGEST}` 来表示它。

记录下输出中的 Package ID，下面的命令使用占位符 `{COMMON_PACKAGE_ID}` 来表示它。

记录下发布交易所创建的这些类型的对象的 ID：

```text
│  │ ObjectID: {COMMON_PACKAGE_PUBLISHER_ID}
│  │ ObjectType: 0x2::package::Publisher

│  │ ObjectID: {EXPERIENCE_TABLE_OBJECT_ID}
│  │ ObjectType: {COMMON_PACKAGE_ID}::experience_table::ExperienceTable

│  │ ObjectID: {ITEM_TABLE_OBJECT_ID}
│  │ ObjectType: {COMMON_PACKAGE_ID}::item::ItemTable

│  │ ObjectID: {ITEM_PRODUCTION_TABLE_OBJECT_ID}
│  │ ObjectType: {COMMON_PACKAGE_ID}::item_production::ItemProductionTable

│  │ ObjectID: {ITEM_CREATION_TABLE_OBJECT_ID}
│  │ ObjectType: {DEFAULT_PACKAGE_ID}::item_creation::ItemCreationTable
```


### 发布 default 合约包

发布 `./sui-contracts/infinite-sea` 目录下的合约项目包。 

记录发布该 default 合约项目的交易摘要，下面的命令使用占位符 `{DEFAULT_PACKAGE_PUBLISH_TRANSACTION_DIGEST}` 来表示它。

记录下该项目的包 ID，下面我们使用占位符 `{DEFAULT_PACKAGE_ID}` 来表示它。

并记录以下类型的对象的 ID：

* 类型为 `0x...::player::PlayerTable` 的对象的 ID，下面我们使用占位符 `{PLAYER_ID}` 来表示它。
* 类型为 `0x2::package::Publisher` 的对象的 ID，下面我们使用占位符 `{DEFAULT_PACKAGE_PUBLISHER_ID}` 来表示它。
* 类型为 `{DEFAULT_PACKAGE_ID}::skill_process::SkillProcessTable` 的对象的 ID，下面我们使用占位符 `{SKILL_PROCESS_TABLE_OBJECT_ID}` 来表示它。


### 初始化经验值表

注意添加经验值表行项的函数参数：

* experience_table: &mut experience_table::ExperienceTable,
* level: u16,
* {COMMON_PACKAGE_PUBLISHER_ID}
* experience: u32,
* difference: u32,

我们在表中添加几行（注意，等级为 0 的第一行虽然没有用到，但是必须添加）：

```shell
sui client call --package {COMMON_PACKAGE_ID} --module experience_table_aggregate --function add_level \
--args {EXPERIENCE_TABLE_OBJECT_ID} {COMMON_PACKAGE_PUBLISHER_ID} '0' '0' '0' \
--gas-budget 11000000

sui client call --package {COMMON_PACKAGE_ID} --module experience_table_aggregate --function add_level \
--args {EXPERIENCE_TABLE_OBJECT_ID} {COMMON_PACKAGE_PUBLISHER_ID} '1' '0' '0' \
--gas-budget 11000000

sui client call --package {COMMON_PACKAGE_ID} --module experience_table_aggregate --function add_level \
--args {EXPERIENCE_TABLE_OBJECT_ID} {COMMON_PACKAGE_PUBLISHER_ID} '2' '83' '83' \
--gas-budget 11000000

sui client call --package {COMMON_PACKAGE_ID} --module experience_table_aggregate --function add_level \
--args {EXPERIENCE_TABLE_OBJECT_ID} '3' '174' '91' \
--gas-budget 11000000
```

你可以这样查看经验表的初始化结果：

```shell
sui client object {EXPERIENCE_TABLE_OBJECT_ID}
```

### 创建 Item

该函数的参数列表：

* item_id: u32,
* publisher: &sui::package::Publisher,
* name: std::ascii::String,
* required_for_completion: bool,
* sells_for: u32,
* item_table: &mut item::ItemTable,

添加第一条记录，这只是一条“占位符”记录，并不会在生产 item 的时候使用：

```shell
sui client call --package {COMMON_PACKAGE_ID} --module item_aggregate --function create \
--args \
'0' \
{COMMON_PACKAGE_PUBLISHER_ID} \
'"UNUSED_ITEM"'  \
'false' \
'0' \
{ITEM_TABLE_OBJECT_ID} \
--gas-budget 11000000
```

添加更多的记录：

```shell
sui client call --package {COMMON_PACKAGE_ID} --module item_aggregate --function create \
--args \
'1' \
{COMMON_PACKAGE_PUBLISHER_ID} \
'"PotatoSeeds"'  \
'false' \
'10' \
{ITEM_TABLE_OBJECT_ID} \
--gas-budget 11000000

sui client call --package {COMMON_PACKAGE_ID} --module item_aggregate --function create \
--args \
'2' \
{COMMON_PACKAGE_PUBLISHER_ID} \
'"Potatoes"'  \
'false' \
'80' \
{ITEM_TABLE_OBJECT_ID} \
--gas-budget 11000000
```


### 创建 Item 生产配方

该函数的参数：

* item_production_id_skill_type: u8,
* item_production_id_item_id: u32,
* publisher: &sui::package::Publisher,
* production_materials_item_id_list: vector<u32>,
* production_materials_item_quantity_list: vector<u32>,
* requirements_level: u16,
* base_quantity: u32,
* base_experience: u32,
* base_creation_time: u64,
* energy_cost: u64,
* success_rate: u16,
* item_production_table: &mut item_production::ItemProductionTable,

我们假设要创建一个“农业”生产配方：种植一份土豆需要 3 个“土豆种子”，等级 1 就可以种植，产出数量为 10，增加经验值为 85，需要 5 秒钟，消耗 100 个单位的能量币，成功率 100%。

执行命令：

```shell
sui client call --package {COMMON_PACKAGE_ID} --module item_production_aggregate --function create \
--args '0' '2' {COMMON_PACKAGE_PUBLISHER_ID} \
'[1]' '[3]' \
'1' '10' '85' '5' '5' '100' \
{ITEM_PRODUCTION_TABLE_OBJECT_ID} \
--gas-budget 11000000
```

记录下创建好的生产配方 Object ID，下面我们以占位符 `{ITEM_PRODUCTION_OBJECT_ID_1}` 来表示它。

```text
│  │ ObjectID: {ITEM_PRODUCTION_OBJECT_ID_1}                                                                                              │
│  │ ObjectType: 0x...::item_production::ItemProduction                                                            │
```

### 创建玩家

```shell
sui client call --package {DEFAULT_PACKAGE_ID} --module player_aggregate --function create \
--gas-budget 11000000
```

记录创建的玩家对象的 ID，下面我们以占位符 `{PLAYER_ID}` 来表示它：

```text
│  │ ObjectID: {PLAYER_ID}
│  │ ObjectType: 0x...::player::Player
```

### 给玩家空投一些资源（Items）

参数：

* player: &mut player::Player,
* publisher: &sui::package::Publisher,
* item_id: u32,
* quantity: u32,

这里我们假设给玩家空投 100 个土豆种子：


```shell
sui client call --package {DEFAULT_PACKAGE_ID} --module player_aggregate --function airdrop \
--args {PLAYER_ID} \
{DEFAULT_PACKAGE_PUBLISHER_ID} \
'1' '100' \
--gas-budget 11000000
```

### 创建一个生产流程

参数：

* skill_process_id_skill_type: u8,
* skill_process_id_player_id: ID,
* player: &Player,
* skill_process_table: &mut skill_process::SkillProcessTable,

执行命令：

```shell
sui client call --package "{DEFAULT_PACKAGE_ID}" --module skill_process_aggregate --function create \
--args '0' {PLAYER_ID} \
{PLAYER_ID} \
"{SKILL_PROCESS_TABLE_OBJECT_ID}" \
--gas-budget 11000000
```

一个示例命令：

```shell
sui client call --package 0x14ba8a9763d9883be8dcedce946efc25e5cbc80c4b8f09d1dbc89731fa517fb8 --module skill_process_aggregate --function create \
--args '0' 0x59e7a3b2d246f7c6852c2f8e953871668db8da387aa551116d1295d223335448 \
0x59e7a3b2d246f7c6852c2f8e953871668db8da387aa551116d1295d223335448 \
0x5689f9e28f3bf359604de4eb85a1c7a55520bd4097b54b42e1acb23c1fc44279 \
--gas-budget 11000000
```

记录下创建好的生产流程的对象 ID，下面我们以占位符 `{SKILL_PROCESS_OBJECT_ID_1}` 来表示它：

```text
│  │ ObjectID: {SKILL_PROCESS_OBJECT_ID_1}
│  │ ObjectType: 0x::skill_process::SkillProcess
```

### 开始生产流程

参数：

* skill_process: &mut SkillProcess,
* player: &mut Player,
* item_production: &ItemProduction,
* clock: &Clock,
* energy: Coin<ENERGY>, 

这样执行命令：

```shell
sui client call --package "{DEFAULT_PACKAGE_ID}" --module skill_process_service --function start_production \
--args "{SKILL_PROCESS_OBJECT_ID_1}" \
"{PLAYER_ID}" \
"{ITEM_PRODUCTION_OBJECT_ID_1}" \
"0x6" \
"{ENERGY_COIN_OBJECT_ID_1}" \
--gas-budget 11000000
```


### 完成生产流程

参数：

* skill_process: &mut skill_process::SkillProcess,
* player: &mut Player,
* item_production: &ItemProduction, 
* experience_table: &ExperienceTable,
* clock: &Clock,

执行：

```shell
sui client call --package "{DEFAULT_PACKAGE_ID}" --module skill_process_aggregate --function complete_production \
--args "{SKILL_PROCESS_OBJECT_ID_1}" \
"{PLAYER_ID}" \
"{ITEM_PRODUCTION_OBJECT_ID_1}" \
"{EXPERIENCE_TABLE_OBJECT_ID}" \
"0x6" \
--gas-budget 11000000 --json > testnet_complete_skill_process.json
```

接下来，我们可以检查执行结果。

先获取玩家拥有的 Items 的 table ID：

```shell
sui client object {PLAYER_ID} --json
```

输出类似：

```text
      "items": {
        "type": "0x2::table::Table<u32, 0x14ba8a9763d9883be8dcedce946efc25e5cbc80c4b8f09d1dbc89731fa517fb8::player_item::PlayerItem>",
        "fields": {
          "id": {
            "id": "0x600ff5d855b5d9ff63edd9d9215457e1c1f6cbb316dc95999ac0d180c886e197"
          },
          "size": "2"
        }
      },
```

获取 table 的“动态字段”信息（你可以把动态字段理解为表的“行”），假设 table Id 是 `0x600ff5d855b5d9ff63edd9d9215457e1c1f6cbb316dc95999ac0d180c886e197`：

```shell
curl -X POST \
-H "Content-Type: application/json" \
-d '{"jsonrpc":"2.0","id":1,"method":"suix_getDynamicFields","params":["0x600ff5d855b5d9ff63edd9d9215457e1c1f6cbb316dc95999ac0d180c886e197"]}' \
https://fullnode.testnet.sui.io/
```

输出类似：

```text
{"jsonrpc":"2.0","result":{"data":[
{"name":{"type":"u32","value":1},"bcsName":"2UzHM","type":"DynamicField","objectType":"0x14ba8a9763d9883be8dcedce946efc25e5cbc80c4b8f09d1dbc89731fa517fb8::player_item::PlayerItem",
"objectId":"0x8655ebf801c0d9f734bc09b9b6aaff781f4d18c66e8ea4e0cb6261315f7b5bee","version":26421773,"digest":"4dCkgDHtD9cbQAz7P9Lveetm7PfSC8DbABfySHYmgTgy"},
{"name":{"type":"u32","value":2},"bcsName":"3xyZh","type":"DynamicField","objectType":"0x14ba8a9763d9883be8dcedce946efc25e5cbc80c4b8f09d1dbc89731fa517fb8::player_item::PlayerItem",
"objectId":"0x970ccbbd1b5670c4f1e13c8a8eafddf53c0a579b158129e961046ee6c321c739","version":26421895,"digest":"4BnmTVdyAgVT8qN7um8h1CXdWpHqjYPQsyMTmYWKaCjr"}
],"nextCursor":"0x970ccbbd1b5670c4f1e13c8a8eafddf53c0a579b158129e961046ee6c321c739","hasNextPage":false},"id":1}
```

通过动态字段的 ID，获取动态字段的内容。示例：

```shell
sui client object 0x8655ebf801c0d9f734bc09b9b6aaff781f4d18c66e8ea4e0cb6261315f7b5bee

sui client object 0x970ccbbd1b5670c4f1e13c8a8eafddf53c0a579b158129e961046ee6c321c739
```


### Test off-chain service

#### Configuring off-chain service

Open the `application-test.yml` file located in the directory `sui-java-service/suiinfinitesea-service-rest/src/main/resources` and set the publishing transaction digests.

After setting, it should look like this:

```yaml
sui:
  contract:
    jsonrpc:
      url: "https://fullnode.testnet.sui.io/"
    package-publish-transactions:
      common: "{COMMON_PACKAGE_PUBLISH_TRANSACTION_DIGEST}"
      default: "{DEFAULT_PACKAGE_PUBLISH_TRANSACTION_DIGEST}"
```

This is the only place where off-chain service need to be configured, and it's that simple.


#### Creating a database for off-chain service

Use a MySQL client to connect to the local MySQL server and execute the following script to create an empty database (assuming the name is `test5`):

```sql
CREATE SCHEMA `test7` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;
```

Go to the `sui-java-service` directory and package the Java project:

```shell
mvn package
```

Then, run a command-line tool to initialize the database:

```shell
java -jar ./suiinfinitesea-service-cli/target/suiinfinitesea-service-cli-0.0.1-SNAPSHOT.jar ddl -d "./scripts" -c "jdbc:mysql://127.0.0.1:3306/test7?enabledTLSProtocols=TLSv1.2&characterEncoding=utf8&serverTimezone=GMT%2b0&useLegacyDatetimeCode=false" -u root -p 123456
```

#### Starting off-chain service

In the `sui-java-service` directory, execute the following command to start the off-chain service:

```shell
mvn -pl suiinfinitesea-service-rest -am spring-boot:run
```
